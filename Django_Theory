CORS  =>  Кроссдоменный запрос. Cross-Origin Resource Sharing (CORS, спільне використання ресурсів з різних джерел) механізм безпеки сучасних браузерів, який дозволяє веб-сторінкам використовувати дані, що знаходяться на інших доменах. Тобто реалізує захист для веб-сторінок, який не відповідають політиці одного походження
Для реалізації цього механізму, веб-сервер з якого завантажується веб-сторінка додає в HTTP-заголовок окремий тег, в якому перераховано домени, з яких веб-сторінка може отримувати дані Access-Control-Allow-Origin

pickling (серялізація) => це перетворення структури даних в послідовність бітів/байтів. Використовується для передачі даних(обєктів) між різними програмами написаних на різних язиках. Цей законсервовний обєк можна сохранити в файл або передати через сеть.

Unpickling (десерялізація) => востановлення структури даних з бітової/байтової послідовності

CASCADE => Каскадное удаление. Django эмулирует поведение SQL правила ON DELETE CASCADE и так же удаляет объекты, связанные через ForeignKey.
Если включен режим каскадного удаления записей, то при удалении записей в главной таблице все связанные записи в подчиненных таблицах удаляются. Это значит, что если вы удалите запись о клиенте из таблицы Клиенты, то Access удалит все записи, относящиеся к данному клиенту в подчиненных таблицах. 
Каскадное удаление (cascade delete) в мире реляционных баз данных позволяет удалять связанные данные из зависимой таблицы, при удалении данных из основной таблицы. В случае модели, которую мы использовали в предыдущих примерах (две связанные таблицы Customer и Order), при использовании каскадного удаления, удаление данных покупателя будет вести к удалению всех связанных с ним заказов. В SQL Server и T-SQL каскадное удаление реализовано в виде опций ON DELETE CASCADE и ON UPDATE CASCADE, которые указываются при объявлении внешнего ключа таблицы.
CASCADE – при удалении или обновлении записи в таблице-предке, которая содержит первичный ключ, автоматически удаляются или обновляются записи со ссылками на это значение в таблице-потомке. В нашем случае, если мы удалим категорию, то удалятся и все вещи, относящиеся к этой категории в таблице вещей. Если мы обновим идентификатор у категории, то у вещей, которые ссылались на эту категорию, идентификатор также изменится на новый.

▶ curl -X POST -d '{"username": "adminAA", "email": "and@gmail.com", "password1": "andriy19921", "password2": "andriy19921"}' -H 'Content-Type: application/json'  http://localhost:8000/api/rest-auth/registration/
▶ curl -X GET http://localhost:8000/api/v1/friends/ -H 'Authorization: Token b3435cdf86617ddf430e2e87bf5a61e649c61d4a'

--------METHOD DJANGO----------

DateField.auto_now_add => Значение поля будет автоматически установлено в текущую дату при создании(первом сохранении) объекта. Полезно для хранения времени создания. Заметим, что текущее время будет использовано всегда; это не просто значение по-умолчанию, которое вы можете переопределить. По этому, даже если вы укажите значение для этого поля, оно будет проигнорировано. Если вы хотите изменять значения этого поля, используйте следующее вместо auto_now_add=True:

permissions.SAFE_METHODS -  має методи які не мають можливості писати тобто GET OPTION.

__str__() – преобразование объекта к строковому представлению, вызывается, когда объект передается функциям print() и str()
__str__(self) - вызывается функциями str, print и format. Возвращает строковое представление объекта.

related_name  => Атрибут related_name указывает имя обратного отношения от модели User к вашей модели
Если вы не укажете related_name, Django автоматически создает имя, используя имя вашей модели с суффиксом _set, например User.map_set.all().
Аргумент related_name также полезен, если у вас есть более сложные имена связанных классов. Например, если у вас есть отношение внешнего ключа.

//-------------------------------------------------------//
path('contact', views.contact - в точності має бути url "contact" a ne "contact/"
re_path(r'^about', views.about) - regularne wyrazenija path maje poczynatys z "about" abo "about/hello/" i  tak wyswitlytsia about request

вначале сравнивается первый маршрут, если он не подходит, то сравнивается второй и так далее.
re_path(r'^about/contact/', views.contact)
re_path(r'^about', views.about)

^(начало адреса)

$(конец адреса)

+(1 и более символов)

?(0 или 1 символ)

{n}(n символов)

{n, m}(от n до m символов)

.(любой символ)

\d+(одна или несколько цифр)

\D+(одна или несколько НЕ цифр)

\w+(один или несколько буквенных символов)


path('products/<int:productid>/', views.products),

str: соответствует любой строке за исключенем символа "/". Если спецификатор не указан, то используется по умолчанию

int: соответствует любому положительному числу

slug: соответствует последовательности буквенных символов ASCII, цифр, дефиса и символа подчеркивания, например, building-your-1st-django-site

uuid: сооветствует идентификатору UUID, например, 075194d3-6885-417e-a8a8-6c931e272f00

path: соответствует любой строке, которая также может включать символ "/" в отличие от спецификатора str


Генерація шаблонів
1) from django.shortcuts import render
2) from django.template.response import TemplateResponse
3) from django.views.generic import TemplateView
